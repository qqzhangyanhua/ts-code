```js
//这个js目前是1500多行
export default {
    residencePermitInfo:
    `/${PREFIX}` + `/${PACKAGENAME}` + '/personalArch/get?key=adecf1a855f4e20e', //居住证信息
  fosterStaffInfo:
    `/${PREFIX}` + `/${PACKAGENAME}` + '/personalArch/get?key=f6197146962277a9', //送养人员信息
  motorVehicleInfo:
    `/${PREFIX}` + `/${PACKAGENAME}` + '/personalArch/get?key=9e262a305498ecc5', //机动车基本信息
  clientInfo:
    `/${PREFIX}` + `/${PACKAGENAME}` + '/personalArch/get?key=6c6fb68911e92335', //客户信息
}
Vue.prototype.$urlMapper = urlMapper
//存在不一定合理



//这类文件不叫多是否考虑可以封装单独处理
const date = dayjs(releaseTime).format("YYYY-MM-DD");

//utils/date.js
import dayJs from "dayjs";
/**
 * 日期格式化
 * @param {String} date
 * @param {*} format
 */
function formatDateSecond(date, format = "YYYY-MM-DD HH:mm:ss") {
  return dayJs(date).format(format);
}
function formatDate(date) {
  return dayJs(date).format('YYYY-MM-DD');
}

// 用到了date-fns 与moment.js 或day.js功能相同，可否考虑用一个替换 dayj相对比较小
//moment.js停止维护了，而且打包比较大，dayjs api基本相同直接替换



//不要直接引用node_modules的.vue文件，在babel转译的时候会有问题
//工具函数，完全可以封装在项目里的utils，这个函数是否有副作用而导致不好treeShaking
import ElImageViewer from "element-ui/packages/image/src/image-viewer.vue";
import { isObject } from '@antv/util'




//判断的时候尽量用=== 不要用==
//关于lodash 这个包导出的时候是全量到处没办法treeShaking 建议用lodash-es  老项目可以逐步迁移
//代码提示型注释，可以保留，因功能迭代一大串不用的代码建议删除


//在route.js
const reservation = () =>
  import(
    /* webpackChunkName: "guide" */ '@shell/components/src/enterprise/reservation/reservation.vue'
  );
const express = () =>
  import(/* webpackChunkName: "guide" */ '@shell/components/src/enterprise/express/express.vue');

const payment = () =>
  import(/* webpackChunkName: "guide" */ '@shell/components/src/enterprise/payment/payment.vue');

//复制的时候注意下，所有的都打包到guide会导致guide这个包过大，不要盲目复制




//为何在route.js会出现直接引入的路由路径
import mainContent from './src/pages/main/main-content';
import messageInfo from '@shell/components/src/enterprise/messageInfo';
import cmNoticeList from './src/pages/notice-list';
import policyInterpretations from './src/pages/policyInterpretations';
import archives from './src/pages/archives';
import appointment from './src/pages/appointment';
import smartGuide from './src/pages/smart-guide';







$img-eindex-radiocode: './assets/images/eindex/随申码专区-home-block.png';
//不要用中文命名，一旦出现奇奇怪怪的问题完全无法排查
//蓝湖拿到的图片比较大的时候不要直接用，发现不少800k 1mb这种图片了
 //可以在这里进行无损压缩大部分能减少60% https://tinypng.com/


 var obj ={
     name: name
          ? name
          : this.$route.query.searchVal
          ? this.$route.query.searchVal
          : this.searchVal
 }
//  三目这么写的话，能够快速看出来这个obj的name属性是什么值吗？




//来自 eslint-plugin-vue插件文档的建议
<script>
  /* ✓ GOOD */
  export default {
    name: 'MyComponent'
  }
</script>

<script>
  /* ✗ BAD */
  export default {
    name: 'my-component'
  }
</script>


<template>
  <!-- ✓ GOOD -->
  <button @click="$emit('myEvent')" />

  <!-- ✗ BAD -->
  <button @click="$emit('my-event')" />
</template>
<script>
export default {
  methods: {
    onClick () {
      /* ✓ GOOD */
      this.$emit('myEvent')
      this.$emit('update:myProp', myProp)

      /* ✗ BAD */
      this.$emit('my-event')
    }
  }
}
</script>






```

    ## 这块代码存在的问题

```html
<li
  v-for="(item, index) in renderData"
  :class="[{ is__song__jiang__hidden: item.id == gqId && isShowZCTJ.region == 'sj' }]"
>
  <div class="project-content-top" @click.stop="gotest(item)">
    <p>
      <!-- <template v-show="curCmp == 'default'">
                            <label
                            :class="{'declaratimg': item.status =='0','notStarted':item.status =='1','complete':item.status =='2'}"
                            >
                              {{item.text}}
                            </label>
                          </template> -->
    </p>
  </div>
</li>
```

```js
// 青浦区，浦东相关代码做了些封装
```

```js
//这个容错是否有必要？？？
_timeFormatIsNull: function (timestamp) {
    if (
      !timestamp||
      timestamp === 'NULL' ||
      timestamp === 'null' ||
      timestamp === 'undefined'
    ) {
      return '-';
    } else {
      const date = new Date(timestamp);
      const Y = date.getFullYear();
      const M = date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1;
      const D = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
      return Y + '-' + M + '-' + D;
    }
  }

有值 没有值  '  '  [],  null  java str:'null;'{}

```

```js
     //一个标准的请求返回值
     {"code":200,"msg":"success","data":{"code":"xxx"}}
     {"code":9998,"msg":"验证码不正确","data":null}

     //假设请求的返回是一个数组 标准返回值
      {"code":200,"msg":"success","data":"[]"}
      {"code":200,"msg":"success","data":[]}
      {"code":200,"msg":"success","data":[1,2,3]}
      // 赋值的时候就是 那么就是用||去赋值
      data = res.data.data || []

      //换个场景，假设请求的返回是一个对象 标准返回值
      {"code":200,"msg":"success","data":null}
      {"code":200,"msg":"success","data":{}}
      {"code":200,"msg":"success","data":{"name":"xxx"}}

      //再换个场景，假设请求的返回是一个字符串 标准返回值
      {"code":200,"msg":"success","data":null}
      {"code":200,"msg":"success","data":""}
      {"code":200,"msg":"success","data":"xxx"}

    // 关于上面的容错,字符串'null'，字符串'undefined'真实的值，如果这个时候去容错，反而会出现问题
    //遇到这种问题怎么处理
    //1.对于后端来说只有null和有值和无值两种情况，所以后端应该返回null和后端沟通
    //2 数据源不在后端，经过后端包装的都让后端一起处理
    //3.如果是第三方数据源，那么就要自己去处理了（但是也要和第三方去沟通，这种情况是不专业的表现）
    //纯测试造的这种数据，就不要去容错了，因为这种数据是不会出现在生产环境的
    //与测试沟通所有非源头造的数据通过sql写入的数据都不要去做容错
    //生产环境不会出现造数据的过程
     timestamp === 'NULL' ||
      timestamp === 'null' ||
      timestamp === 'undefined'

    //目前我们返回的值,可能因为历史遗留问题，或者其他供应商的数据没有进行包装才出现的，在开发中，我们尽可能和我们对应的开发的后端去处理，去规范下返回值。
   1. {"result":0,"timeStamp":1666773627051,"message":"{\"code\":0,\"msg\":\"success\",\"length\":0,\"data\":{\"shuiwuju_yshd_fzxx_2q\":null}}"}
   json.parse('')
   20111/11/11
   rfc3399 时间戳
   2.{"result":0,"message":{Code:0,Msg:"接口调用成功"}}
   3. {"tongVersion":"1.0","errorCode":0,"result":0,"message":"SUCCESS","errMsg":null,"data":[]}
   4.{"msg":"操作失败!","code":"500","data":"","version":"0.1","isSuccess":false}
   5.{"code":200,"data":"","message":"操作成功!"}

```


```js
````


 ### 设计模式
      - 工厂模式
      - 单例模式
      - 代理模式
      - 观察者模式
      - 中介者模式
      - 命令模式
      - 组合模式
      - 装饰者模式
      - 策略模式
      - 模板方法模式
      - 享元模式
      - 迭代器模式
      - 发布订阅模式
      - 职责链模式
      - 适配器模式
      - 状态模式
      - 代理模式
      - 门面模式
      - 组合模式
