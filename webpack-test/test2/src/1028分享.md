观察者（Observer）模式中包含两种对象，分别是目标对象和观察者对象。在目标对象和观察者对象间存在着一种一对多的对应关系，当这个目标对象的状态发生变化时，所有依赖于它的观察者对象都会得到通知并执行它们各自特有的行为。

通俗地说，就好像这些观察者对象在时刻注视着目标对象（被观察）。无论何时该目标对象的状态发生变化，这些观察者对象都能够马上知道，并根据目标对象的新状态执行相应的任务。

```js
let activeEffect = null;
class Dep {
    constructor(val) {
        this._val = val;
        this.effects = new Set();
    }
    get value() {
        this.depend();
        return this._val;
    }
    set value(newVal) {
        this._val = newVal;
        this.notify();
    }
    //收集依赖
    depend() {
        if (activeEffect) {
            this.effects.add(activeEffect);
        }
    }
    //派发依赖
    notify() {
        this.effects.forEach(effect => effect());
    }
}
const ref = (value) => {
    return new Dep(value);
}
const effect = (fn) => {
    activeEffect = fn;
    fn();
    activeEffect = null;
}
const a = ref(10)
let b;
effect(() => {
    b = a.value + 1
})
// console.log('b===',b); // b=== 11
// a.value++
// console.log('b===',b);// b=== 12
let targetMap = new Map;

const reactive = (raw) => {
    return new Proxy(raw, {
        get(target, key) {
            let depsMap = targetMap.get(target)
            if (!depsMap) {
                depsMap = new Map();
                targetMap.set(target, depsMap)
            }
            let dep = depsMap.get(key)
            if (!dep) {
                dep = new Dep();
                depsMap.set(key, dep)
            }
            dep.depend()
            return Reflect.get(target, key)
        },
        set(target, key, value) {
            let depsMap = targetMap.get(target)
            if (!depsMap) {
                depsMap = new Map();
                targetMap.set(target, depsMap)
            }
            let dep = depsMap.get(key)
            if (!dep) {
                dep = new Dep();
                depsMap.set(key, dep)
            }
            const result = Reflect.set(target, key, value)
            dep.notify()
            return result
        }
    })
}
let user = reactive({
    age: 11
})
let double;
effect(() => {
    double = user.age * 2
})
console.log('double===', double); // double=== 22
user.age++;
console.log('double===', double); // double=== 24




// 策略模式
const getPrice = (from, rate) => {
    if (from === 'wb') {
        if(rate>200){
            return rate-50
        }
        return rate * 0.8
    } else if (from === 'qq') {
        return rate * 0.9
    } else if (from === 'wx') {
        return rate * 0.7
    } else if(from==='dy'){
        return rate*0.6
    }else {
        return rate
    }
}
const froms ={
    wb(rate){

        return rate*0.8
    },
    qq(){},
    wx(){},
    dy(){},
    default(){

    }
}

const getPrice2 = (from, rate) => {

    return froms[from](rate)
}




// 单例模式

 class Stroge{
   getInstance(){
        
        if(!Stroge.instance){
            Stroge.instance = new Stroge()
        }
        return Stroge.instance
   }
    setItem(key,value){
       localStorage.setItem(key,value)
    }
    getItem(key){
       return localStorage.getItem(key)
    }

 }

// 全局弹框



let stroge1 = Stroge.getInstance();
let stroge2 = Stroge.getInstance();
stroge1.setItem('name','zyh')
console.log(stroge2.getItem('name')) 

console.log(stroge1 === stroge2); //true
```