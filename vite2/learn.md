<!--
 * @Author: ZYH
 * @Date: 2022-08-24 08:42:45
 * @LastEditTime: 2022-08-24 09:43:16
 * @Description: 
-->

### 早期模块化处理方式
 - 文件划分
 - 命名空间
 - IIFE（立即执行函数）




 - 我们知道，每个IIFE 即立即执行函数都会创建一个私有的作用域，在私有作用域中的变量外界是无法访问的，只有模块内部的方法才能访问
 - 但实际上，无论是命名空间还是IIFE，都是为了解决全局变量所带来的命名冲突及作用域不明确的问题
 - CommonJS 是业界最早正式提出的 JavaScript 模块规范，主要用于服务端的模块加载，它的设计思想是尽量的兼容 Node.js 的模块机制，所以它的模块加载机制是同步的，也就是说，只有加载完成，才能执行后面的操作用域
    - 模块加载器由 Node.js 提供，依赖了 Node.js 本身的功能实现，比如文件系统，如果 CommonJS 模块直接放到浏览器中是无法执行的。当然, 业界也产生了 browserify 这种打包工具来支持打包 CommonJS 模块，从而顺利在浏览器中执行，相当于社区实现了一个第三方的 loader。
    - CommonJS 本身约定以同步的方式进行模块加载，这种加载机制放在服务端是没问题的，一来模块都在本地，不需要进行网络 IO，二来只有服务启动时才会加载模块，而服务通常启动后会一直运行，所以对服务的性能并没有太大的影响。但如果这种加载机制放到浏览器端，会带来明显的性能问题。它会产生大量同步的模块请求，浏览器要等待响应返回后才能继续解析模块。也就是说，模块请求会造成浏览器 JS 解析过程的阻塞，导致页面加载速度缓慢。

- AMD全称为Asynchronous Module Definition，即异步模块定义规范。而不会像 CommonJS 规范进行同步加载，也就不会产生同步请求导致的浏览器解析过程阻塞的问题了

- ES6 Module 也被称作 ES Module(或 ESM)， 是由 ECMAScript 官方提出的模块化规范，作为一个官方提出的规范，ES Module 已经得到了现代浏览器的内置支持。在现代浏览器中，如果在 HTML 中加入含有type="module"属性的 script 标签，那么浏览器会按照 ES Module 规范来进行依赖加载和模块解析，这也是 Vite 在开发阶段实现 no-bundle 的原因，由于模块加载的任务交给了浏览器，即使不打包也可以顺利运行模块代码

- 如果在 Node.js 环境中，你可以在package.json中声明type: "module"属性:
````js
// package.json
{
  "type": "module"
}
````
